package basic;

public class Chapter7 {

	public static void main(String[] args) {
		/*
		 * 트리
		 * 사이클이 없는 그래프
		 * 그래서 정점이 v개면 간선의 개수는 v-1개
		 * 하지만, 정점이 v개고 간선의 개수가 v-1개면 모두 트리는 아니다
		 * a-b d-e  이렇게 된 그래프도 존재 할 수 있기 때문이다.
		 * |/  |
		 * c   f
		 * 
		 * ex) 도시가 n개 도로가 n-1개 + 임의의 두 도시 사이에는 경로가 항상 존재한다, 두 도시사이에 경로가 1개 밖에 업다 ==> 트리
		 * 
		 * 그래서 '정점이 v개면 간선의 개수는 v-1개' 이 조건에 모든 정점들은 연결되어있다 라는 조건이 붙으면 트리라고 할 수 있다.
		 * 
		 *  루트는 꼭 위에 있을 필요는 없다. 하지만 그림그릴때는 주로 위에 그린다.
		 *  
		 *  루트부터 아래로 방향을 정할 수잇다.->부모 관계 설정 가능
		 *  
		 *  부모가 없는 놈 -> 루트
		 *  
		 *  자식이 없으면 단말 정점.(leaf node)
		 *  
		 *  같은 부모를 가진 노드들 ->형제관계(sibling)
		 *  
		 *  깊이(depth) 루트에서부터 거리
		 *  
		 *  높이(height) 깊이 중에서 가장 큰 값
		 *  
		 *  조상: p->q를 갈 수 있을때,
		 *   p가 q보다 루트에 가까우면 
		 *   p는 q의 조상(자기자신도 포함)
		 *   q는 p의 자손
		 *   
		 *   이진트리 : 자식을 최대 2개만 가지고 있는 트리(binary tree)
		 *   
		 *   트리도 그래프 이기 떄문에 그래프와 같은 방식으로 저장할 수 있다.
		 *   인접리스트 사용
		 *   
		 *   이진트리 순회 방법(이 방법들은 노드 방문을 언제하냐 차이)
		 *   프리오더(그래프의 dfs와 순서가 같다)
		 *   	- 노드 방문
		 *   	- 왼쪽 자식 노드를 루트로 하는 프리 오더
		 *   	- 오른쪽 자식 노드를 루트로 하는 프리 오더
		 *   인오더(binary search tree에서 delete 구현시 사용)
		 *   	- 왼쪽 자식 노드를 루트로 하는 인 오더
		 *   	- 노드 방문
		 *   	- 오른쪽 자식 노드를 루트로 하는 인 오더
		 *   포스트오더(제일많이사용 ex)어떤 노드 처리하기 전에 자식 노드 처리해야하는 상황일때)
		 *   	- 왼쪽 자식 노드를 루트로 하는 포스트 오더
		 *   	- 오른쪽 자식 노드를 루트로 하는 포스트 오더
		 *   	- 노드 방문
		 *   
		 *   이진트리가 아닌 경우(자식이 2개가 아닌 여러개인 경우)에 탐색하는 방법은 프리와 포스트이다.
		 *   프리오더를 표현하자면 [root][childeren] 이런식으로 탐색 하고
		 *   포스트오더를 표현하자면 [childeren][root] 이런식으로 탐색 하게 된다.
		 *   하지만 인 오더는 [chlidren][root][children] 식으로 탐색하게 되니 루트를 탐색할 타이밍을 찾기가 어렵기 때문이다.
		 *   
		 *   
		 * 
		 */
	}
}
